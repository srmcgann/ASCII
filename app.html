<!DOCTYPE html>
<html>
  <head>
    <title>Coordinates boilerplate example</title>
    <style>
      body, html{
        background: #000;
        margin: 0;
        min-height: 100vh;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script type="module">
    
      import * as Coordinates from
      "https://srmcgann.github.io/tempppp/coordinates.min.js"
      //"https://whr.rf.gd/coordinates.js?2"

      var rendererOptions = {
        ambientLight: .05, margin: 0, fov: 1e3,
        width: 1024, height: 1024
      }
      var renderer = await Coordinates.Renderer(rendererOptions)
      Coordinates.AnimationLoop(renderer, 'Draw')
      
      var rsz
      var frameCount = 0
      
      window.addEventListener('resize', rsz = () => {
      
        Coordinates.Overlay.rsz = () => {}
        
        renderer.c.style.display    = 'block'
        Coordinates.Overlay.c.style.display    = 'block'
        
        renderer.c.style.position   = 'absolute'
        Coordinates.Overlay.c.style.position   = 'absolute'
        
        var bodyWidth = document.body.clientWidth
        var bodyHeight = document.body.clientHeight
        
        if(bodyWidth/bodyHeight < 1){
          renderer.c.style.left                  = `${bodyWidth/2}px`
          renderer.c.style.right                 = 'unset'
          renderer.c.style.top                   = '5px'
          renderer.c.style.bottom                = 'unset'
          
          Coordinates.Overlay.c.style.left       = `${bodyWidth/2}px`
          Coordinates.Overlay.c.style.right      = 'unset'
          Coordinates.Overlay.c.style.top        = 'unset'
          Coordinates.Overlay.c.style.bottom     = '5px'
          
          renderer.c.style.transform             = 'translate(-50%, 0)'
          Coordinates.Overlay.c.style.transform  = 'translate(-50%, 0)'
          renderer.c.style.width = (bodyHeight / 2 - 10) + 'px'
          renderer.c.style.height = (bodyHeight / 2 - 10) + 'px'
          Coordinates.Overlay.c.style.width = (bodyHeight / 2 - 10) + 'px'
          Coordinates.Overlay.c.style.height = (bodyHeight / 2 - 10) + 'px'
        }else{
          renderer.c.style.left                  = '5px'
          renderer.c.style.right                 = 'unset'
          renderer.c.style.top                   = '50vh'
          renderer.c.style.bottom                = 'unset'
          
          Coordinates.Overlay.c.style.left       = 'unset'
          Coordinates.Overlay.c.style.right      = '5px'
          Coordinates.Overlay.c.style.top        = '50vh'
          Coordinates.Overlay.c.style.bottom     = 'unset'
          
          renderer.c.style.transform             = 'translate(0, -50%)'
          Coordinates.Overlay.c.style.transform  = 'translate(0, -50%)'
          renderer.c.style.width = (bodyWidth / 2 - 10) + 'px'
          renderer.c.style.height = (bodyWidth / 2 - 10) + 'px'
          Coordinates.Overlay.c.style.width = (bodyWidth / 2 - 10) + 'px'
          Coordinates.Overlay.c.style.height = (bodyWidth / 2 - 10) + 'px'
        }
        
      })
      rsz()
      
      
      var asciiURL = 'https://www.tiqets.com/blog/wp-content/uploads/2023/01/Mona_Lisa.jpg'
      
      
      renderer.z = 10
      var gamma = .75
      var ascii = true
      var fontSize = 40
      var monochrome = false
      var monochromeColor = 0x00ff44
      var colorizeOutput = false
      var outputToConsole = false
      var outputToConsoleOnce = true
      
      if(location.href.split('url=').length > 1){
        asciiURL = location.href.split('url=')[1].split('&')[0]
      }
      
      if(asciiURL.toLowerCase().indexOf('.mp4') != -1){
        var asciiImage = document.createElement('video')
        asciiImage.muted = true
        asciiImage.loop = true
        asciiImage.autoplay = true
      }else{
        var asciiImage = new Image()
      }
      
      if(location.href.split('gamma=').length > 1){
        gamma = eval(location.href.split('gamma=')[1].split('&')[0])
      }
      if(location.href.split('ascii=').length > 1){
        ascii = eval(location.href.split('ascii=')[1].split('&')[0])
      }
      if(location.href.split('fontsize=').length > 1){
        fontSize = location.href.split('fontsize=')[1].split('&')[0]
      }
      if(location.href.split('monochrome=').length > 1){
        monochrome = eval(location.href.split('monochrome=')[1].split('&')[0])
      }
      if(location.href.split('monochromecolor=').length > 1){
        monochromeColor = eval(location.href.split('monochromecolor=')[1].split('&')[0])
      }
      if(location.href.split('colorizeoutput=').length > 1){
        colorizeOutput = eval(location.href.split('colorizeoutput=')[1].split('&')[0])
      }
      if(location.href.split('outputtoconsole=').length > 1){
        outputToConsole = eval(location.href.split('outputtoconsole=')[1].split('&')[0])
      }
      if(location.href.split('outputtoconsoleonce=').length > 1){
        outputToConsoleOnce = eval(location.href.split('outputtoconsoleonce=')[1].split('&')[0])
      }

      var shaderOptions = [
        { uniform: {
          type: 'phong',
          value: .5
        } }
      ]
      var shader = await Coordinates.BasicShader(renderer, shaderOptions)

      var shaderOptions = [
        { lighting: {type: 'ambientLight', value: gamma} },
        { uniform: {
          type: 'phong',
          value: 0
        } }
      ]
      var screenShader = await Coordinates.BasicShader(renderer, shaderOptions)
      
      //await fetch(asciiURL).then(res=>res.blob()).then(data => asciiImage.src = URL.createObjectURL(data))
      asciiImage.src = asciiURL
      var asciiImageLoaded = false
      var shapes = []
      
      asciiImage[asciiURL.toLowerCase().indexOf('.mp4') != -1 ? 'oncanplay' : 'onload'] = async () => {
        asciiImageLoaded = true
        var geoOptions = {
          shapeType: 'rectangle',
          name: 'screen',
          scaleX: 100 * (asciiURL.toLowerCase().indexOf('.mp4') != -1 ? (asciiImage.videoWidth/asciiImage.videoHeight) : (asciiImage.width/asciiImage.height)),
          scaleY: -100,
          map: asciiURL,
          color: 0x4400ff,
          colorMix: 0,
          z: 100,
        }
        await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
          shapes.push(geometry)
          await screenShader.ConnectGeometry(geometry)
        })  
      }
      
      var outputtedFrame = false
      window.Draw = () => {
        var t = renderer.t
        renderer.Clear()
        shapes.forEach(shape => {
          switch(shape.name){
            case 'screen':
              renderer.Draw(shape)
            break
            default:
              renderer.Draw(shape)
            break
          }
        })
        if(ascii) {
          var text = Coordinates.SceneToASCII(renderer, {
            fontSize,
            monochrome,
            backgroundColor: 0x333333,
            monochromeColor,
            outputToConsoleOnce,
            colorizeOutput,
          })
          if(text){
            top.window.ASCIIData = {
              frameCount: frameCount++,
              text: text.replaceAll('%%','%'),
              columns: text.split("\n")[0].length,
              rows: text.length / text.split("\n")[0].length | 0,
            }
            if(!outputtedFrame){
              outputtedFrame = true
            }
          }
        }
      }
      
    </script>
  </body>
</html>


